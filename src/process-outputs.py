#!/usr/bin/env python
import argparse
import fileinput
import re
import sys


def create_item_map(file: str):
    """ Create dictionary representing item map from the csv file (number, string). """
    items_map = {}
    with open(file, 'r') as f:
        for line in filter(lambda x: x.strip(), f):  # Filter out empty lines
            number, string = tuple(map(lambda x: x.strip(), line.split(',')))
            items_map[int(number)] = string
    return items_map


def file_lines(file: str):
    """ Calculate number of lines in file. """
    with open(file) as f:
        i = 0
        for i, l in enumerate(f, start=1):
            pass
    return i


def process_outputs(input_db: str, output_file: str, percentage_support: bool = True, precision: int = None):
    """
    Process outputs of SPMF. This function rewrites output_file.
        * Replace numeric representation of items with string representation based on .map file.
        * Calculate percentage support.
    :param input_db: Path to database on which the patterns/rules were generated.
    :param output_file: Path to file with patterns/rules generated by SPMF.
    :param percentage_support: if true, percentage support will be calculated.
    :param precision: Round numbers to given precision
    """
    item_map = create_item_map(input_db + ".map")

    if percentage_support:
        number_of_sequences = file_lines(input_db)

    for line in fileinput.input(output_file, inplace=1):
        pattern, supp_conf = line.split("#SUP:")
        supp, conf = (supp_conf.split("#CONF:") + [""])[:2]

        # Map all positive numbers (items) to string representation
        new_pattern = re.sub("(?<![-\d])\d+", lambda x: item_map[int(x.group(0))], pattern)

        # Calculate percentage value of support
        if percentage_support:
            supp = int(supp)
            per_support = round(supp / number_of_sequences, precision) if precision else supp / number_of_sequences
            supp = f"{per_support} ({supp}/{number_of_sequences})"

        # Round confidence if present
        conf = round(float(conf), precision) if precision and conf.strip() else conf.strip()

        # Write out processed line
        new_line = f"{new_pattern}#SUP: {supp}" + (f" #CONF: {conf}" if conf else "")
        print(new_line, file=sys.stdout)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description="Process outputs of SPMF. This script rewrites --output-file. \n"
                                                 "   * Replace numeric representation of items with string "
                                                 "representation based on .map file.\n"
                                                 "   * Calculate percentage support.")
    parser.add_argument("-d", "--database",
                        required=True,
                        help="Path to database on which the patterns/rules were generated. Script assumes that .map "
                             "file for database is in same directory as database.",
                        type=str)
    parser.add_argument("-o", "--output-file",
                        required=True,
                        help="Path to the output file of SPMF. E.g. file with rules or patterns. "
                             "The file will be modified.",
                        type=str)
    parser.add_argument("--no-support", help="Do not calculate percentage support.", action="store_true")
    parser.add_argument("--precision", help="Round numbers to given precision.", type=int)
    args = parser.parse_args()

    process_outputs(args.database, args.output_file, percentage_support=not args.no_support, precision=args.precision)
